\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdq{}\PYGZdq{}\PYGZdq{}
Generar eventos MIDI a partir de cada pista
\PYGZdq{}\PYGZdq{}\PYGZdq{}
EVENTOS = []
for pista in PISTAS:
  momento = 0
  track = pista.orden
  EVENTOS.append([
    \PYGZsq{}addTrackName\PYGZsq{},
    track,
    momento,
    pista.nombre
  ])

  EVENTOS.append([
    \PYGZsq{}addCopyright\PYGZsq{},
    track,
    momento,
    args.copyright
  ])

  parte = \PYGZbs{}\PYGZob{}
     \PYGZsq{}orden\PYGZsq{}     : track,
     \PYGZsq{}nombre\PYGZsq{}    : pista.nombre,
     \PYGZsq{}comienzo\PYGZsq{}  : comienzo,
     \PYGZsq{}etiquetas\PYGZsq{} : [],
  \PYGZbs{}\PYGZcb{}
  duracion\PYGZus{}parte = 0

  \PYGZdq{}\PYGZdq{}\PYGZdq{}
  Loop principal:
  Genera una secuencia de eventos MIDI lista de articulaciones.
  \PYGZdq{}\PYGZdq{}\PYGZdq{}
  for index, articulacion in enumerate( pista.secuencia ):

    \PYGZdq{}\PYGZdq{}\PYGZdq{}
    TO DO: agregar funcciones de midiutil adicionales:
    https://midiutil.readthedocs.io/en/1.2.1/class.html\PYGZsh{}classref
    [x] addCopyright
    [x] addPitchWheelEvent
    [x] changeNoteTunig
    [ ] changeTuningBank
    [ ] changeTuningProgram
    [x] addSysEx
    [x] addUniversalSysEx
    [x] makeNRPNCall
    [x] makeRPNCall
    \PYGZdq{}\PYGZdq{}\PYGZdq{}

    verboseprint( articulacion )
    precedente = pista.secuencia[ index \PYGZhy{} 1 ]
    unidad     = articulacion[ \PYGZsq{}unidad\PYGZsq{} ]
    canal      = articulacion[ \PYGZsq{}canal\PYGZsq{} ]
    bpm        = articulacion[ \PYGZsq{}bpm\PYGZsq{} ]
    metro      = articulacion[ \PYGZsq{}metro\PYGZsq{} ].split( \PYGZsq{}/\PYGZsq{} )
    clave      = articulacion[ \PYGZsq{}clave\PYGZsq{} ]
    programa   = articulacion[ \PYGZsq{}programa\PYGZsq{} ]
    duracion   = articulacion[ \PYGZsq{}duracion\PYGZsq{} ]
    tono       = articulacion[ \PYGZsq{}tono\PYGZsq{} ]

    \PYGZdq{}\PYGZdq{}\PYGZdq{}
    Primer articulación de la parte, agregar eventos fundamentales: pulso,
    armadura de clave, compás y programa.
    \PYGZdq{}\PYGZdq{}\PYGZdq{}
    if ( index == 0 ):
      EVENTOS.append([
        \PYGZsq{}addTempo\PYGZsq{},
        track,
        momento,
        bpm
      ])

      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      Clave de compás
      https://midiutil.readthedocs.io/en/1.2.1/class.html\PYGZsh{}midiutil.MidiFile.MIDIFile.addTimeSignature
      denominator  = potencia negativa de 2: log10( X ) / log10( 2 )
      2 representa  una negra, 3 una corchea, etc.
      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      numerador        = int( metro[0] )
      denominador      = int( math.log10( int( metro[1] ) ) / math.log10( 2 ) )
      relojes\PYGZus{}por\PYGZus{}tick = 12 * denominador
      notas\PYGZus{}por\PYGZus{}pulso = 8
      EVENTOS.append([
        \PYGZsq{}addTimeSignature\PYGZsq{},
        track,
        momento,
        numerador,
        denominador,
        relojes\PYGZus{}por\PYGZus{}tick,
        notas\PYGZus{}por\PYGZus{}pulso
      ])

      EVENTOS.append([
        \PYGZsq{}addKeySignature\PYGZsq{},
        track,
        momento,
        clave[ \PYGZsq{}alteraciones\PYGZsq{} ],
        \PYGZsh{} multiplica por el n de alteraciones
        1,
        clave[ \PYGZsq{}modo\PYGZsq{} ]
      ])

      EVENTOS.append([
        \PYGZsq{}addProgramChange\PYGZsq{},
        track,
        canal,
        momento,
        programa
      ])

    \PYGZdq{}\PYGZdq{}\PYGZdq{}
    TO DO: Crear estructura superiores a articulacion llamada segmento
    parametros de que ahora son relativios a la aritulacion \PYGZsh{}0
    \PYGZdq{}\PYGZdq{}\PYGZdq{}
    \PYGZdq{}\PYGZdq{}\PYGZdq{}
    Primer articulacion de la Unidad,
    inserta etiquetas y modificadores de unidad (desplazar).
    \PYGZdq{}\PYGZdq{}\PYGZdq{}
    if ( articulacion[ \PYGZsq{}orden\PYGZsq{} ] == 0 ):
      desplazar = articulacion[ \PYGZsq{}desplazar\PYGZsq{} ]
      \PYGZsh{} TODO raise error si desplazar + duracion es negativo
      momento += desplazar

      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      Compone texto de la etiqueta a partir de nombre de unidad, numero de
      iteración y referentes
      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      texto = \PYGZsq{}\PYGZsq{}
      ers = referir( articulacion[ \PYGZsq{}referente\PYGZsq{} ] ) if articulacion[ \PYGZsq{}referente\PYGZsq{} ] != None else [ ( 0, 0 ) ]
      prs = [ ( 0, 0 ) ]
      if precedente[ \PYGZsq{}referente\PYGZsq{} ] != None:
        prs = referir( precedente[ \PYGZsq{}referente\PYGZsq{} ] )
      for er, pr in zip( ers , prs ):
        if er != pr:
          texto += str( er[ 0 ] ) + \PYGZsq{} \PYGZsh{}\PYGZsq{} + str( er[ 1 ] ) + \PYGZsq{}saltodelinea\PYGZsq{}
      texto += unidad
      EVENTOS.append([
       \PYGZsq{}addText\PYGZsq{},
        track,
        momento,
        texto
      ])
      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      changeNoteTuning
      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      if articulacion[ \PYGZsq{}afinacionNota\PYGZsq{} ]:
        EVENTOS.append([
         \PYGZsq{}changeNoteTuning\PYGZsq{},
          track,
          articulacion[ \PYGZsq{}afinacionNota\PYGZsq{} ][ \PYGZsq{}afinaciones\PYGZsq{} ],
          articulacion[ \PYGZsq{}afinacionNota\PYGZsq{} ][ \PYGZsq{}canalSysEx\PYGZsq{} ],
          articulacion[ \PYGZsq{}afinacionNota\PYGZsq{} ][ \PYGZsq{}tiempoReal\PYGZsq{} ],
          articulacion[ \PYGZsq{}afinacionNota\PYGZsq{} ][ \PYGZsq{}programa\PYGZsq{} ],
        ])
      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      SysEx
      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      if articulacion[ \PYGZsq{}sysEx\PYGZsq{} ]:
        EVENTOS.append([
         \PYGZsq{}addSysEx\PYGZsq{},
          track,
          momento,
          articulacion[ \PYGZsq{}sysEx\PYGZsq{} ][ \PYGZsq{}fabricante\PYGZsq{} ],
          articulacion[ \PYGZsq{}sysEx\PYGZsq{} ][ \PYGZsq{}playload\PYGZsq{} ],
        ])
      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      UniversalSysEx
      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      if articulacion[ \PYGZsq{}uniSysEx\PYGZsq{} ]:
        EVENTOS.append([
         \PYGZsq{}addUniversalSysEx\PYGZsq{},
          track,
          momento,
          articulacion[ \PYGZsq{}uniSysEx\PYGZsq{} ][ \PYGZsq{}codigo\PYGZsq{} ],
          articulacion[ \PYGZsq{}uniSysEx\PYGZsq{} ][ \PYGZsq{}subCodigo\PYGZsq{} ],
          articulacion[ \PYGZsq{}uniSysEx\PYGZsq{} ][ \PYGZsq{}playload\PYGZsq{} ],
          articulacion[ \PYGZsq{}uniSysEx\PYGZsq{} ][ \PYGZsq{}canal\PYGZsq{} ],
          articulacion[ \PYGZsq{}uniSysEx\PYGZsq{} ][ \PYGZsq{}tiempoReal\PYGZsq{} ],
        ])
      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      Numero de Parametro No Registrado
      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      if articulacion[ \PYGZsq{}NRPN\PYGZsq{} ]:
        EVENTOS.append([
         \PYGZsq{}makeNRPNCall\PYGZsq{},
          track,
          canal,
          momento,
          articulacion[ \PYGZsq{}NRPN\PYGZsq{} ][ \PYGZsq{}control\PYGZus{}msb\PYGZsq{} ],
          articulacion[ \PYGZsq{}NRPN\PYGZsq{} ][ \PYGZsq{}control\PYGZus{}lsb\PYGZsq{} ],
          articulacion[ \PYGZsq{}NRPN\PYGZsq{} ][ \PYGZsq{}data\PYGZus{}msb\PYGZsq{} ],
          articulacion[ \PYGZsq{}NRPN\PYGZsq{} ][ \PYGZsq{}data\PYGZus{}lsb\PYGZsq{} ],
          articulacion[ \PYGZsq{}NRPN\PYGZsq{} ][ \PYGZsq{}ordenar\PYGZsq{} ],
        ])

      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      Numero de Parametro Registrado
      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      if articulacion[ \PYGZsq{}RPN\PYGZsq{} ]:
        EVENTOS.append([
         \PYGZsq{}makeRPNCall\PYGZsq{},
          track,
          canal,
          momento,
          articulacion[ \PYGZsq{}RPN\PYGZsq{} ][ \PYGZsq{}control\PYGZus{}msb\PYGZsq{} ],
          articulacion[ \PYGZsq{}RPN\PYGZsq{} ][ \PYGZsq{}control\PYGZus{}lsb\PYGZsq{} ],
          articulacion[ \PYGZsq{}RPN\PYGZsq{} ][ \PYGZsq{}data\PYGZus{}msb\PYGZsq{} ],
          articulacion[ \PYGZsq{}RPN\PYGZsq{} ][ \PYGZsq{}data\PYGZus{}lsb\PYGZsq{} ],
          articulacion[ \PYGZsq{}RPN\PYGZsq{} ][ \PYGZsq{}ordenar\PYGZsq{} ],
        ])

      etiqueta = \PYGZob{}
        \PYGZsq{}texto\PYGZsq{}  : texto,
        \PYGZsq{}cuando\PYGZsq{} : momento,
        \PYGZsh{}\PYGZsq{}hasta\PYGZsq{} : duracion\PYGZus{}unidad,
      \PYGZcb{}
      parte[ \PYGZsq{}etiquetas\PYGZsq{} ].append( etiqueta )
      \PYGZsh{} Termina articulacion 0, estos van a ser parametros de Segmento

    \PYGZdq{}\PYGZdq{}\PYGZdq{}
    Agrega cualquier cambio de parametro,
    comparar cada uno con la articulacion previa.
    \PYGZdq{}\PYGZdq{}\PYGZdq{}
    if ( precedente[\PYGZsq{}bpm\PYGZsq{}] != bpm ):
      EVENTOS.append([
        \PYGZsq{}addTempo\PYGZsq{},
        track,
        momento,
        bpm,
      ])

    if ( precedente[ \PYGZsq{}metro\PYGZsq{} ] != metro ):
      numerador        = int( metro[ 0 ] )
      denominador      = int( math.log10( int( metro[ 1 ] ) ) / math.log10( 2 ) )
      relojes\PYGZus{}por\PYGZus{}tick = 12 * denominador
      notas\PYGZus{}por\PYGZus{}pulso = 8
      EVENTOS.append([
        \PYGZsq{}addTimeSignature\PYGZsq{},
        track,
        momento,
        numerador,
        denominador,
        relojes\PYGZus{}por\PYGZus{}tick,
        notas\PYGZus{}por\PYGZus{}pulso
      ])

    if ( precedente[ \PYGZsq{}clave\PYGZsq{} ] != clave ):
      EVENTOS.append([
        \PYGZsq{}addKeySignature\PYGZsq{},
        track,
        momento,
        clave[ \PYGZsq{}alteraciones\PYGZsq{} ],
        1, \PYGZsh{} multiplica por el n de alteraciones
        clave[ \PYGZsq{}modo\PYGZsq{} ]
      ])

    \PYGZsh{}if programa:
    if ( precedente[ \PYGZsq{}programa\PYGZsq{} ] != programa ):
      EVENTOS.append([
         \PYGZsq{}addProgramChange\PYGZsq{},
         track,
         canal,
         momento,
         programa
      ])
    \PYGZsh{}midi\PYGZus{}bits.addText( pista.orden, momento , \PYGZsq{}prgm : \PYGZsh{}\PYGZsq{} + str( programa ) )

    if ( precedente[ \PYGZsq{}tono\PYGZsq{} ] != tono ):
      EVENTOS.append([
         \PYGZsq{}addPitchWheelEvent\PYGZsq{},
         track,
         canal,
         momento,
         tono
      ])


    \PYGZdq{}\PYGZdq{}\PYGZdq{}
    Agregar nota/s (altura, duracion, dinamica).
    Si existe acorde en la articulación armar una lista con cada voz superpuesta.
    o una lista de solamente un elemento.
    \PYGZdq{}\PYGZdq{}\PYGZdq{}
    voces = articulacion[ \PYGZsq{}acorde\PYGZsq{} ] if articulacion[ \PYGZsq{}acorde\PYGZsq{} ] else [ articulacion[ \PYGZsq{}altura\PYGZsq{} ] ]
    dinamica = int( articulacion[ \PYGZsq{}dinamica\PYGZsq{} ] * 126 )
    for voz in voces:
      altura = voz
      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      Si la articulacion es un silencio (S) agregar nota sin altura ni dinamica.
      \PYGZdq{}\PYGZdq{}\PYGZdq{}
      if voz == \PYGZsq{}S\PYGZsq{}:
        dinamica = 0
        altura = 0
      EVENTOS.append([
        \PYGZsq{}addNote\PYGZsq{},
        track,
        canal,
        altura,
        momento,
        duracion,
        dinamica,
      ])


    \PYGZdq{}\PYGZdq{}\PYGZdq{}
    Agregar cambios de control
    \PYGZdq{}\PYGZdq{}\PYGZdq{}
    if articulacion[ \PYGZsq{}controles\PYGZsq{} ]:
      for control in articulacion[ \PYGZsq{}controles\PYGZsq{} ]:
        for control, valor in control.items():
          EVENTOS.append([
           \PYGZsq{}addControllerEvent\PYGZsq{},
            track,
            canal,
            momento,
            control,
            valor,
          ])


    momento += duracion
    duracion\PYGZus{}parte += ( duracion *  60 ) / bpm

  PARTES.append( parte )
\end{Verbatim}
